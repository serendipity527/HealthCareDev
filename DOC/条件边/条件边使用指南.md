# 条件边（Conditional Edges）使用指南

## 概述

条件边（Conditional Edges）是 LangGraph4j 中用于实现动态路由的核心功能。它允许根据状态或配置信息，在运行时决定图的下一个执行节点，从而实现智能的流程控制。

本指南总结了 `ConditionalEdgeDemo` 目录中的四个示例，展示了不同场景下如何使用条件边进行意图识别和路由。

## 目录

1. [基础意图识别示例](#基础意图识别示例)
2. [意图识别示例（标准版）](#意图识别示例标准版)
3. [意图识别替代方案示例](#意图识别替代方案示例)
4. [LLM意图识别示例](#llm意图识别示例)

---

## 基础意图识别示例

**文件**: `BasicIntentRecognitionExample.java`

### 核心概念

展示如何使用简单的规则或逻辑实现意图识别，并根据识别出的意图路由到不同的子图进行处理。

### 适用场景

- 意图类型明确且有限
- 可以通过关键词或简单规则识别
- 不需要复杂的自然语言理解

### 关键组件

#### 1. 状态定义

```java
static class State extends AgentState {
    public Optional<String> intent() {
        return value("intent");
    }
    
    public Optional<String> input() {
        return value("input");
    }
}
```

#### 2. 意图识别节点

使用关键词匹配进行意图识别：

```java
static class IntentRecognizeNode implements NodeAction<State> {
    private String recognizeIntent(String input) {
        String lowerInput = input.toLowerCase();
        
        if (lowerInput.contains("解释") || lowerInput.contains("explain")) {
            return "explain";
        } else if (lowerInput.contains("查询") || lowerInput.contains("query")) {
            return "query";
        } else if (lowerInput.contains("计算") || lowerInput.contains("calculate")) {
            return "calculate";
        } else {
            return "general";
        }
    }
}
```

#### 3. 子图创建

为每种意图创建独立的子图：

- `createExplainSubGraph()` - 处理解释意图
- `createQuerySubGraph()` - 处理查询意图
- `createCalculateSubGraph()` - 处理计算意图
- `createGeneralSubGraph()` - 处理通用意图

#### 4. 条件边配置

```java
.addConditionalEdges("intent_recognize",
    edge_async(state -> state.intent().orElseThrow()),
    Map.of(
        "explain", "explain_agent",
        "query", "query_agent",
        "calculate", "calculate_agent",
        "general", "general_agent"
    ))
```

### 图结构

```
START → intent_recognize → [条件路由]
                              ├─ explain → explain_agent → END
                              ├─ query → query_agent → END
                              ├─ calculate → calculate_agent → END
                              └─ general → general_agent → END
```

---

## 意图识别示例（标准版）

**文件**: `IntentRecognitionExample.java`

### 核心概念

展示标准的意图识别流程：`START → 意图识别 → 三个分支 → END`

### 关键特性

- 使用 `AsyncCommandAction` 定义条件路由
- 意图存储在状态中，便于持久化和调试
- 清晰的节点职责分离

### 关键组件

#### 1. 状态定义

```java
static class IntentState extends AgentState {
    public static final String INTENT_KEY = "intent";
    public static final String INPUT_KEY = "input";
    public static final String RESULT_KEY = "result";
    
    public static final Map<String, Channel<?>> SCHEMA = Map.of(
        INTENT_KEY, Channels.base(() -> null),
        INPUT_KEY, Channels.base(() -> null),
        RESULT_KEY, Channels.base(() -> null)
    );
}
```

#### 2. 路由函数

```java
static AsyncCommandAction<IntentState> routeByIntent = (state, config) -> {
    String intent = state.intent()
        .orElseThrow(() -> new IllegalStateException("意图未识别"));
    
    return completedFuture(new Command(intent));
};
```

**重要说明**：
- `Command.gotoNode()` 返回的字符串必须匹配 `mappings` 中的 key
- 路由函数接收 `(state, config)` 两个参数
- 可以从状态、config.metadata 或直接计算获取意图

#### 3. 条件边配置

```java
.addConditionalEdges(
    "intent_recognize",           // 源节点
    routeByIntent,                // 条件路由函数
    Map.of(
        "query", "query_branch",
        "purchase", "purchase_branch",
        "other", "other_branch"
    )
)
```

### 图结构

```
START → intent_recognize → [条件路由]
                              ├─ query → query_branch → END
                              ├─ purchase → purchase_branch → END
                              └─ other → other_branch → END
```

---

## 意图识别替代方案示例

**文件**: `IntentRecognitionAlternativeExample.java`

### 核心概念

展示三种不同的方式传递意图信息，帮助开发者选择最适合自己场景的方案。

### 三种方案对比

#### 方式1：意图放在状态中（推荐）

**优点**：
- 便于持久化和调试
- 意图信息可以在整个流程中访问
- 适合需要多次使用意图的场景

**实现**：

```java
static class StateWithIntent extends SimpleState {
    public static final String INTENT_KEY = "intent";
    
    public Optional<String> intent() {
        return this.<String>value(INTENT_KEY);
    }
}

static AsyncCommandAction<StateWithIntent> routeByIntent1 = (state, config) -> {
    String intent = state.intent()
        .orElseThrow(() -> new IllegalStateException("意图未识别"));
    return completedFuture(new Command(intent));
};
```

#### 方式2：意图放在 config.metadata 中

**优点**：
- 适合临时数据
- 不占用状态空间

**限制**：
- 节点无法直接修改 config
- 需要在外部设置或在节点返回的 Command 中处理
- 路由函数可以读取 metadata

**注意**：此方式在实际应用中较少使用，因为节点无法直接修改 config。

#### 方式3：在路由函数中直接计算（推荐用于简单逻辑）

**优点**：
- 最简单，不需要存储意图
- 减少状态管理复杂度
- 适合简单的意图识别逻辑

**实现**：

```java
static AsyncCommandAction<SimpleState> routeByIntent3 = (state, config) -> {
    String input = state.input().orElse("");
    
    String intent;
    if (input.contains("查询") || input.contains("query")) {
        intent = "query";
    } else if (input.contains("购买") || input.contains("buy")) {
        intent = "purchase";
    } else {
        intent = "other";
    }
    
    return completedFuture(new Command(intent));
};
```

### 方案选择建议

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 意图需要多次使用 | 方式1（状态中） | 避免重复计算 |
| 简单关键词匹配 | 方式3（直接计算） | 代码简洁 |
| 需要调试意图 | 方式1（状态中） | 便于查看状态 |
| 复杂意图识别逻辑 | 方式1（状态中） | 逻辑分离清晰 |

---

## LLM意图识别示例

**文件**: `LLMIntentRecognitionExample.java`

### 核心概念

使用大语言模型（LLM）来理解用户意图，并根据识别出的意图智能路由到不同的处理节点。

### 适用场景

- 需要理解复杂的自然语言
- 意图类型多样且可能重叠
- 需要上下文理解
- 意图识别准确度要求高

### 关键组件

#### 1. 监督者代理（Supervisor Agent）

使用 LLM 进行意图识别和路由决策：

```java
static class SupervisorAgent implements NodeAction<State> {
    interface Service {
        @SystemMessage("""
            You are a supervisor tasked with managing a conversation 
            between the following workers: {{members}}.
            Given the following user request, respond with the worker to act next.
            """)
        Router evaluate(@V("members") String members,
                       @UserMessage String userMessage);
    }
    
    static class Router {
        @Description("Worker to route to next. If no workers needed, route to FINISH.")
        String next;
    }
}
```

#### 2. 工作代理

- **ResearchAgent**: 处理研究、查询、信息检索等任务
- **CoderAgent**: 处理编程、计算、代码相关任务
- **WriterAgent**: 处理写作、内容生成、文本创作等任务

#### 3. 循环路由结构

工作节点完成后返回监督者，可以继续处理或结束：

```java
.addEdge("researcher", "supervisor")
.addEdge("coder", "supervisor")
.addEdge("writer", "supervisor")
```

### 图结构

```
START → supervisor → [条件路由]
                      ├─ FINISH → END
                      ├─ researcher → supervisor (循环)
                      ├─ coder → supervisor (循环)
                      └─ writer → supervisor (循环)
```

### 配置要求

运行此示例需要配置 LLM 模型：

```java
// 使用 Ollama
ChatModel model = OllamaChatModel.builder()
    .baseUrl("http://localhost:11434")
    .modelName("llama3")
    .temperature(0.0)
    .build();

// 或使用 OpenAI
ChatModel model = OpenAiChatModel.builder()
    .apiKey("your-key")
    .build();
```

---

## 核心 API 说明

### addConditionalEdges 方法

```java
public StateGraph<State> addConditionalEdges(
    String sourceId,                    // 源节点ID
    AsyncCommandAction<State> condition, // 条件判断逻辑，返回 Command
    Map<String, String> mappings        // 条件值到目标节点的映射
)
```

### Command 类

```java
class Command {
    String gotoNode;                    // 路由函数返回的字符串（对应 mappings 的 key）
    Map<String, Object> update;         // 可选的状态更新
}
```

### AsyncCommandAction 接口

```java
@FunctionalInterface
interface AsyncCommandAction<State> {
    CompletableFuture<Command> apply(State state, RunnableConfig config);
}
```

---

## 最佳实践

### 1. 意图存储位置选择

- **简单逻辑**：在路由函数中直接计算（方式3）
- **复杂逻辑**：存储在状态中（方式1）
- **需要持久化**：存储在状态中（方式1）

### 2. 路由函数设计

- 确保返回的字符串匹配 `mappings` 中的 key
- 处理异常情况（如意图未识别）
- 考虑添加默认路由（如 "other" 或 "general"）

### 3. 状态管理

- 使用 `Channels` 定义状态模式
- 选择合适的 Channel 类型（`lastWrite`, `base`, 等）
- 保持状态结构清晰和可维护

### 4. 错误处理

```java
static AsyncCommandAction<State> routeByIntent = (state, config) -> {
    String intent = state.intent()
        .orElseThrow(() -> new IllegalStateException("意图未识别"));
    // 或提供默认值
    // .orElse("default");
    
    return completedFuture(new Command(intent));
};
```

### 5. 调试技巧

- 在路由函数中添加日志输出
- 使用状态中的意图字段便于调试
- 检查 `mappings` 中的 key 是否与路由函数返回值匹配

---

## 常见问题

### Q1: 路由函数返回的字符串不在 mappings 中怎么办？

**A**: 会抛出异常。确保路由函数返回的字符串必须匹配 `mappings` 中的 key，或者添加默认路由。

### Q2: 可以在路由函数中修改状态吗？

**A**: 可以。`Command` 类支持 `update` 字段，可以在路由时更新状态：

```java
return completedFuture(new Command(intent, Map.of("someKey", "someValue")));
```

### Q3: 如何实现多级路由？

**A**: 可以在子图中再次使用条件边，实现多级路由决策。

### Q4: 路由函数是同步还是异步的？

**A**: 使用 `AsyncCommandAction` 是异步的，返回 `CompletableFuture<Command>`。如果需要同步，可以使用 `CommandAction`。

---

## 总结

条件边是 LangGraph4j 中实现动态流程控制的核心功能。通过本指南中的四个示例，你可以：

1. **基础场景**：使用简单规则进行意图识别和路由
2. **标准流程**：实现标准的意图识别流程
3. **灵活选择**：根据场景选择最适合的意图传递方式
4. **智能路由**：使用 LLM 进行复杂的意图识别

选择合适的方案取决于你的具体需求：
- 简单关键词匹配 → 方式3（直接计算）
- 需要持久化意图 → 方式1（状态中）
- 复杂自然语言理解 → LLM 方式

希望本指南能帮助你更好地理解和使用条件边功能！

