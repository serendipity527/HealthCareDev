# LangGraph4j 使用指南：创建接受用户输入并调用大模型的Graph

本指南将帮助你了解如何使用 langgraph4j 创建一个 graph，该 graph 能够接受用户输入，调用大模型生成回答，然后返回给用户。

## 核心概念

### 1. State（状态）
State 是 graph 中存储数据的容器。你需要：
- 定义一个继承自 `AgentState` 的状态类
- 定义状态 schema（使用 `Channel` 来定义每个字段的类型和更新规则）

### 2. Node（节点）
Node 是 graph 中的执行单元。每个节点：
- 接收当前状态作为输入
- 执行某些操作（如调用大模型）
- 返回状态更新（`Map<String, Object>`）

### 3. Edge（边）
Edge 定义节点之间的连接关系，决定执行流程。

## 基本步骤

### 步骤1：定义状态类

```java
import org.bsc.langgraph4j.state.AgentState;
import org.bsc.langgraph4j.state.Channel;
import org.bsc.langgraph4j.state.Channels;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

class ChatState extends AgentState {
    // 定义状态schema
    public static final Map<String, Channel<?>> SCHEMA = Map.of(
            "messages", Channels.appender(ArrayList::new),  // 对话历史列表
            "user_input", Channels.base(() -> null),        // 用户输入
            "model_response", Channels.base(() -> null)     // 模型回答
    );

    public ChatState(Map<String, Object> initData) {
        super(initData);
    }

    // 便捷方法
    public List<String> messages() {
        return this.<List<String>>value("messages")
                .orElse(new ArrayList<>());
    }

    public Optional<String> userInput() {
        return this.<String>value("user_input");
    }

    public Optional<String> modelResponse() {
        return this.<String>value("model_response");
    }
}
```

**说明：**
- `Channels.appender()`: 用于列表类型，新值会被追加到列表中
- `Channels.base()`: 用于普通值类型，新值会替换旧值

### 步骤2：创建节点

节点是实现了 `AsyncNodeAction<State>` 接口的函数，接收状态并返回状态更新。

```java
import org.bsc.langgraph4j.action.AsyncNodeAction;
import static org.bsc.langgraph4j.action.AsyncNodeAction.node_async;

// 节点1：接收用户输入
AsyncNodeAction<ChatState> receiveUserInputNode = node_async(state -> {
    String userInput = state.userInput()
            .orElseThrow(() -> new RuntimeException("用户输入不能为空"));
    
    // 返回状态更新
    return Map.of(
            "messages", userInput,      // 将用户输入添加到messages
            "user_input", null          // 清空user_input
    );
});

// 节点2：调用大模型
AsyncNodeAction<ChatState> callLLMNode = node_async(state -> {
    List<String> messages = state.messages();
    String lastUserMessage = messages.get(messages.size() - 1);
    
    // 调用大模型（这里需要替换为真实的API调用）
    String modelResponse = callLLM(lastUserMessage);
    
    return Map.of(
            "messages", modelResponse,
            "model_response", modelResponse
    );
});
```

### 步骤3：构建Graph

```java
import org.bsc.langgraph4j.StateGraph;
import org.bsc.langgraph4j.CompiledGraph;
import static org.bsc.langgraph4j.StateGraph.START;
import static org.bsc.langgraph4j.StateGraph.END;

// 创建StateGraph
StateGraph<ChatState> graph = new StateGraph<>(ChatState.SCHEMA, ChatState::new)
        .addNode("receive_input", receiveUserInputNode)  // 添加节点
        .addNode("call_llm", callLLMNode)
        .addEdge(START, "receive_input")                 // 添加边
        .addEdge("receive_input", "call_llm")
        .addEdge("call_llm", END);

// 编译graph
CompiledGraph<ChatState> compiledGraph = graph.compile();
```

### 步骤4：执行Graph

```java
// 准备输入数据
Map<String, Object> inputs = Map.of(
        "user_input", "你好，请介绍一下Java"
);

// 方式1：使用invoke方法（获取最终状态）
Optional<ChatState> finalState = compiledGraph.invoke(inputs);
if (finalState.isPresent()) {
    ChatState state = finalState.get();
    System.out.println("模型回答: " + state.modelResponse().orElse("无"));
}

// 方式2：使用stream方法（逐步查看执行过程）
for (var output : compiledGraph.stream(inputs)) {
    System.out.println("节点: " + output.node());
    System.out.println("状态: " + output.state().data());
}
```

## 集成真实大模型API

### 使用 OpenAI

首先添加依赖：
```xml
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-open-ai</artifactId>
    <version>0.29.1</version>
</dependency>
```

然后在节点中调用：
```java
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.model.chat.ChatLanguageModel;

ChatLanguageModel chatModel = OpenAiChatModel.builder()
        .apiKey(System.getenv("OPENAI_API_KEY"))
        .modelName("gpt-4o-mini")
        .temperature(0.7)
        .maxTokens(1000)
        .build();

String response = chatModel.generate(userInput);
```

### 使用 Claude

添加依赖：
```xml
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-anthropic</artifactId>
    <version>0.29.1</version>
</dependency>
```

调用：
```java
import dev.langchain4j.model.anthropic.AnthropicChatModel;

ChatLanguageModel chatModel = AnthropicChatModel.builder()
        .apiKey(System.getenv("ANTHROPIC_API_KEY"))
        .modelName("claude-3-sonnet-20240229")
        .build();

String response = chatModel.generate(userInput);
```

### 使用本地 Ollama

添加依赖：
```xml
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-ollama</artifactId>
    <version>0.29.1</version>
</dependency>
```

调用：
```java
import dev.langchain4j.model.ollama.OllamaChatModel;

ChatLanguageModel chatModel = OllamaChatModel.builder()
        .baseUrl("http://localhost:11434")
        .modelName("llama2")
        .build();

String response = chatModel.generate(userInput);
```

## 完整示例

参考项目中的示例文件：
- `SimpleLLMGraphExample.java` - 基础示例（模拟大模型调用）
- `RealLLMGraphExample.java` - 集成真实大模型API的示例

## 高级特性

### 1. 条件分支

使用 `addConditionalEdges` 可以根据条件选择不同的路径：

```java
graph.addConditionalEdges("node1", 
    edge_async(state -> {
        // 根据状态返回不同的路由键
        return state.someCondition() ? "path_a" : "path_b";
    }),
    Map.of(
        "path_a", "node_a",
        "path_b", "node_b"
    )
);
```

### 2. 并行执行

多个节点可以并行执行：

```java
graph.addEdge("node1", "node_a")
     .addEdge("node1", "node_b")
     .addEdge("node1", "node_c");
// node_a, node_b, node_c 会并行执行
```

### 3. 状态持久化

使用 `CheckpointSaver` 可以保存和恢复状态：

```java
import org.bsc.langgraph4j.checkpoint.MemorySaver;
import org.bsc.langgraph4j.CompileConfig;
import org.bsc.langgraph4j.RunnableConfig;

MemorySaver saver = new MemorySaver();
CompileConfig compileConfig = CompileConfig.builder()
        .checkpointSaver(saver)
        .build();

CompiledGraph<ChatState> compiledGraph = graph.compile(compileConfig);

RunnableConfig config = RunnableConfig.builder()
        .threadId("user-123")
        .build();

compiledGraph.invoke(inputs, config);
```

## 常见问题

### Q: 如何传递多个输入参数？
A: 在 `invoke` 方法的 `Map` 中可以包含多个键值对：
```java
Map<String, Object> inputs = Map.of(
        "user_input", "问题",
        "context", "上下文信息",
        "temperature", 0.7
);
```

### Q: 如何在节点中访问之前的对话历史？
A: 通过状态的 `messages()` 方法获取：
```java
List<String> messages = state.messages();
// messages 包含所有历史消息
```

### Q: 如何处理异步操作？
A: `AsyncNodeAction` 本身就支持异步，返回 `CompletableFuture`：
```java
AsyncNodeAction<ChatState> asyncNode = node_async(state -> {
    CompletableFuture<Map<String, Object>> future = 
        CompletableFuture.supplyAsync(() -> {
            // 异步操作
            return Map.of("result", "value");
        });
    return future;
});
```

## 参考资源

- 项目示例：`how-tos/getting-started.ipynb`
- 测试用例：`langgraph4j-core/src/test/java/org/bsc/langgraph4j/StateGraphTest.java`
- Agent Executor示例：`how-tos/agentexecutor.ipynb`

